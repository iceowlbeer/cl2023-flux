loki:
  ## Affinity for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  # podAntiAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #   - labelSelector:
  #       matchExpressions:
  #       - key: app
  #         operator: In
  #         values:
  #         - loki
  #     topologyKey: "kubernetes.io/hostname"

  ## StatefulSet annotations
  annotations: {}
  # enable tracing for debug, need install jaeger and specify right jaeger_agent_host
  tracing:
    jaegerAgentHost:

  config:
    server:
      http_listen_port: 3100

    auth_enabled: false
    distributor:
      ring:
        kvstore:
          store: memberlist

    ingester:
      chunk_idle_period: 3m
      chunk_block_size: 262144
      chunk_retain_period: 1m
      max_transfer_retries: 0
      lifecycler:
        ring:
          kvstore:
            store: memberlist
          replication_factor: 1

    memberlist:
      abort_if_cluster_join_fails: false
      bind_port: 7946

      # You can use a headless k8s service for all distributor,
      # ingester and querier components.
      join_members:
      - loki-gossip-ring.monitoring.svc.cluster.local:7946

      max_join_backoff: 1m
      max_join_retries: 10
      min_join_backoff: 1s
        
    limits_config:
      enforce_metric_name: false
      reject_old_samples: true
      reject_old_samples_max_age: 168h
      retention_period: 744h

    schema_config:
      configs:
      - from: "2020-10-24"
        store: boltdb-shipper
        object_store: aws
        schema: v11
        index:
          prefix: index_
          period: 24h
    
    storage_config:
      aws:
        endpoint: frsjez6mlvwx.compat.objectstorage.eu-frankfurt-1.oraclecloud.com
        region: eu-frankfurt-1
        bucketnames: lokilogging
        access_key_id: 0d959e08681346c1cb269536a1a55dc7cee5ae69
        secret_access_key: t8ii3vcF3OdCz3zuU9XiyYnHh6Aq7qW5ColW3S9uzLU=
        insecure: false
        sse_encryption: false
        http_config:
          idle_conn_timeout: 90s
          response_header_timeout: 0s
          insecure_skip_verify: false
        s3forcepathstyle: true
      boltdb_shipper:
        active_index_directory: /data/loki/boltdb-shipper-active
        cache_location: /data/loki/boltdb-shipper-cache
        cache_ttl: 24h         # Can be increased for faster performance over longer query periods, uses more disk space
        shared_store: aws
    chunk_store_config:
      max_look_back_period: 672h #28days
    compactor:
      working_directory: /data/loki/boltdb-shipper-compactor
      shared_store: aws
      compaction_interval: 5m
      retention_enabled: true
      retention_delete_delay: 2h
      retention_delete_worker_count: 150
    
    query_scheduler:
      max_outstanding_requests_per_tenant: 2048

    query_range:
      parallelise_shardable_queries: false
      split_queries_by_interval: 0

  ## Additional Loki container arguments, e.g. log level (debug, info, warn, error)
  extraArgs: {}
  #extraArgs:
  #  log.level: debug

  livenessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  ## ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
  networkPolicy:
    enabled: false

  ## The app name of loki clients
  client: {}
    # name:

  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  nodeSelector: {}

  ## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
  ## If you set enabled as "True", you need :
  ## - create a pv which above 10Gi and has same namespace with loki
  ## - keep storageClassName same with below setting
  persistence:
    enabled: true
    accessModes:
    - ReadWriteOnce
    size: 10Gi
    annotations: {}
    # selector:
    #   matchLabels:
    #     app.kubernetes.io/name: loki
    # subPath: ""
    # existingClaim:

  ## Pod Labels
  podLabels: {}

  ## Pod Annotations
  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "http-metrics"

  podManagementPolicy: OrderedReady

  rbac:
    create: true
    pspEnabled: true

  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45

  replicas: 1

  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

  securityContext:
    fsGroup: 10001
    runAsGroup: 10001
    runAsNonRoot: true
    runAsUser: 10001

  service:
    type: ClusterIP
    nodePort:
    port: 3100
    annotations: {}
    labels: {}

  serviceAccount:
    create: true
    name:
    annotations: {}

  terminationGracePeriodSeconds: 4800

  ## Tolerations for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  tolerations: []

  # The values to set in the PodDisruptionBudget spec
  # If not set then a PodDisruptionBudget will not be created
  podDisruptionBudget: {}
  # minAvailable: 1
  # maxUnavailable: 1

  updateStrategy:
    type: RollingUpdate

  serviceMonitor:
    enabled: true
    interval: ""
    namespace: "monitoring"
    namespaceSelector: 
      any: true
    #additionalLabels: 
    #  release: prometheus-stack
    annotations: {}
    # scrapeTimeout: 10s

  initContainers: []
  ## Init containers to be added to the loki pod.
  # - name: my-init-container
  #   image: busybox:latest
  #   command: ['sh', '-c', 'echo hello']

  extraContainers: []
  ## Additional containers to be added to the loki pod.
  # - name: reverse-proxy
  #   image: angelbarrera92/basic-auth-reverse-proxy:dev
  #   args:
  #     - "serve"
  #     - "--upstream=http://localhost:3100"
  #     - "--auth-config=/etc/reverse-proxy-conf/authn.yaml"
  #   ports:
  #     - name: http
  #       containerPort: 11811
  #       protocol: TCP
  #   volumeMounts:
  #     - name: reverse-proxy-auth-config
  #       mountPath: /etc/reverse-proxy-conf


  extraVolumes: []
    
  ## Additional volumes to the loki pod.
  # - name: reverse-proxy-auth-config
  #   secret:
  #     secretName: reverse-proxy-auth-config

  ## Extra volume mounts that will be added to the loki container
  extraVolumeMounts: []
  

  extraPorts: []
  ## Additional ports to the loki services. Useful to expose extra container ports.
  # - port: 11811
  #   protocol: TCP
  #   name: http
  #   targetPort: http

  # Extra env variables to pass to the loki container
  env: []

  alerting_groups:
    - name: should_fire
      rules:
        - alert: HighPercentageError
          expr: |
            sum(rate({app="promtail", namespace="monitoring"} |= "error" [5m])) by (job)
              /
            sum(rate({app="promtail", namespace="monitoring"}[5m])) by (job)
              > 0.05
          for: 10m
          labels:
              severity: page
          annotations:
              summary: High request latency
    - name: credentials_leak
      rules: 
        - alert: http-credentials-leaked
          annotations: 
            message: "{{ $labels.job }} is leaking http basic auth credentials."
          expr: 'sum by (cluster, job, pod) (count_over_time({namespace="prod"} |~ "http(s?)://(\\w+):(\\w+)@" [5m]) > 0)'
          for: 10m
          labels: 
            severity: critical

promtail:
  enabled: true
  
  serviceMonitor:
    # -- If enabled, ServiceMonitor resources for Prometheus Operator are created
    enabled: true
    namespace: "monitoring"
    namespaceSelector: 
        any: true
    #additionalLabels: 
    #  release: prometheus-stack
    annotations: {}

  snippets:
    pipelineStages:
      - cri: {}
      - drop:
          expression: ".*category=SEC.*"

  extraVolumes:
  - name: okedocker
    hostPath:
      path: /u01/data

  extraVolumeMounts:
  - name: okedocker
    mountPath: /u01/data
    readOnly: true